# Problem 4
import numpy as np

TWO_PI = 2*np.pi

def getAngle():
    global TWO_PI
    # return an angle that represents a point on the circle
    return TWO_PI*np.random.rand()

def getPoint():
    x = np.random.rand()
    y = np.random.rand()
    while x**2 + y**2 > 1:
        x = np.random.rand()
        y = np.random.rand()
    return [x,y]

def getLengthChord(point1, point2):
    # get the line generated by the points: line(t) = v*t + point1
    v1, v2 = point1[0]-point2[0], point1[1]-point2[1]
    def line(t):
        v = np.array([v1, v2])
        p = np.array(point1)
        return t*v + p
    # get intercepts with the circle
    a = (v1**2 + v2**2)
    b = (2*v1*point1[0] + 2*v2*point1[1])
    c = point1[0]**2 + point1[1]**2 -1
    t1 = (-b + (b**2 - 4*a*c)**0.5)/(2*a)
    t2 = (-b - (b**2 - 4*a*c)**0.5)/(2*a)
    x = line(t1)
    y = line(t2)
    return np.linalg.norm(x-y)
    
def simulationA(N):
    global TWO_PI
    angle_equilateral = TWO_PI/3
    success_count = 0
    for _ in range(N):
        point1 = getAngle()
        point2 = getAngle()
        angle = min([abs(point1-point2), TWO_PI -abs(point1-point2)])
        if angle > angle_equilateral:
            success_count += 1
    return success_count/N

def simulationB(N):
    radius_equilateral = 0.5
    success_count = 0
    for _ in range(N):
        point = getPoint()
        radius = (point[0]**2 + point[1]**2)**0.5
        if radius > radius_equilateral:
            success_count += 1
    return success_count/N

def simulationC(N):
    side_equilateral = 3**0.5
    success_count = 0
    for _ in range(N):
        point1 = getPoint()
        point2 = getPoint()
        len_chord = getLengthChord(point1, point2)
        if len_chord > side_equilateral:
            success_count += 1
    return success_count/N

if __name__ == "__main__":
    N = 10**5
    
    # problem 4 a.
    print(simulationA(N))
    
    # problem 4 b.
    print(simulationB(N))
    
    # problem 4 c.
    print(simulationC(N))

